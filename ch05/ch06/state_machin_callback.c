/* Реализация конечного автомата через калбек-функции на языке C  */

#include <stdio.h>

// Определение состояний автомата
typedef enum {
    STATE_INIT,    // Начальное состояние
    STATE_WAIT,    // Состояние ожидания
    STATE_PROCESS, // Состояние обработки
    STATE_END      // Конечное состояние
} State;

// Определение типа указателя на функцию, представляющую состояние
typedef void (*StateFunc)();

// Объявление функций, которые будут выполнять действия для каждого состояния
void state_init();
void state_wait();
void state_process();
void state_end();

// Текущая переменная, указывающая на состояние автомата
State current_state = STATE_INIT;

// Массив указателей на функции, соответствующие состояниям автомата
StateFunc state_functions[] = {
    state_init,    // Функция для состояния STATE_INIT
    state_wait,    // Функция для состояния STATE_WAIT
    state_process, // Функция для состояния STATE_PROCESS
    state_end      // Функция для состояния STATE_END
};

// Реализация функции для начального состояния
void state_init() {
    printf("Initializing...\n");
    // Переход в состояние ожидания
    current_state = STATE_WAIT;
}

// Реализация функции для состояния ожидания
void state_wait() {
    printf("Waiting...\n");
    // Переход в состояние обработки
    current_state = STATE_PROCESS;
}

// Реализация функции для состояния обработки
void state_process() {
    printf("Processing...\n");
    // Переход в конечное состояние
    current_state = STATE_END;
}

// Реализация функции для конечного состояния
void state_end() {
    printf("Ending...\n");
    // Здесь состояние не изменяется, так как это конечное состояние
}

int main() {
    // Основной цикл, выполняющий переходы между состояниями
    while (current_state != STATE_END) {
        // Вызов функции, соответствующей текущему состоянию
        state_functions[current_state]();
    }
    // Дополнительный вызов для последнего состояния
    state_functions[current_state]();  // Последний вызов для STATE_END
    return 0;
}

/*
Пояснения:
    Определение состояний: Используется enum для создания набора возможных состояний конечного автомата.

    Тип указателя на функцию: StateFunc определяет тип функций, которые будут использоваться для обработки каждого состояния. Это функции, которые не принимают аргументов и не возвращают значение.

    Функции для каждого состояния: Каждая функция реализует логику, связанную с определённым состоянием, и определяет, в какое следующее состояние нужно перейти.

    Массив функций: state_functions — это массив указателей на функции, где каждая функция соответствует одному из состояний автомата.

    Основной цикл: В main() программа зацикливается до тех пор, пока текущее состояние не станет конечным (STATE_END). На каждой итерации вызывается функция, соответствующая текущему состоянию автомата.
*/