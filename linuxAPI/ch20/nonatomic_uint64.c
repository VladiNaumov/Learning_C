/* nonatomic_uint64.c

   На x86-32, операции записи и чтения 64-битных целых чисел не являются атомарными.
   Это может привести к "разрыву памяти" при чтении и записи, когда доступ к памяти требует двух транзакций по шине.
   Таким образом, чтение целого числа, которое модифицируется на другом процессоре, может привести к получению половины старого значения и половины нового значения.
   Например, 64-битное целое число не может безопасно использоваться в качестве флага, который устанавливается обработчиком сигнала и проверяется основной программой.

   Эта программа демонстрирует это поведение. Обработчик сигнала инвертирует 64-битное целое число, изначально равное нулю, так что значение постоянно переключается между всеми битами, равными нулю, и всеми битами, равными единице.
   Основная программа многократно извлекает копию этого числа и выводит сообщение, когда извлечённое значение не равно всем нулям или всем единицам.

   Скомпилируйте эту программу с флагом -m32, и запустите её:

        $ cc -o nonatomic_uint64 -m32 nonatomic_uint64.c
        $ ./nonatomic_uint64
        Unexpected: ffffffff00000000 (loop 48533)
        Unexpected: ffffffff00000000 (loop 171488)
        Unexpected: 00000000ffffffff (loop 272321)
        Unexpected: 00000000ffffffff (loop 297708)

   На Ubuntu и Debian вам, возможно, нужно будет установить пакет 'gcc-multilib', чтобы скомпилировать эту программу с описанными выше параметрами.
*/
#include <inttypes.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define SIG SIGUSR1

static volatile uint64_t ip = 0;  /* 'volatile' добавлено здесь только для демонстрации,
                                      что это не помогает. */

/* Обработчик сигнала инвертирует биты в '*ip'; это может быть не атомарно. */

static void
handler(int sig)
{
    ip = ~ip;
}

int
main(int argc, char *argv[])
{
    /* Настройка обработчика сигнала. */

    struct sigaction sa;

    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIG, &sa, NULL) == -1)
        errExit("sigaction");

    /* Создание дочернего процесса, который будет посылать сигналы родительскому процессу. */

    pid_t childPid = fork();
    if (childPid == -1)
        errExit("fork");

    if (childPid == 0) {
        while (1) {
            if (kill(getppid(), SIG) == -1)
                errExit("kill() failed in child");
        }
    }

    /* Родительский процесс продолжает выполнение */

    /* Цикл, в котором извлекается значение '*ip' (извлечение может быть не атомарным),
       и проверяется, является ли результат всеми нулями или всеми единицами.
       Если это не так, выводится извлечённое значение и номер итерации. */

    for (int long long j = 0; ; j++) {
        uint64_t loc = ip;
        if (loc != 0 && loc != ~0)
            printf("Unexpected: %016" PRIx64 " (loop %lld)\n", loc, j);
    }

    exit(EXIT_SUCCESS);
}
/*
### Резюме:
Эта программа демонстрирует проблему с атомарностью операций записи и чтения 64-битных целых чисел на архитектуре x86-32. На этой архитектуре операции с 64-битными числами могут быть не атомарными, что приводит к "разрыву" памяти (memory tearing) при одновременном доступе к одному и тому же значению с разных процессоров или потоков.

1. **Основная логика**:
   - Программа включает обработчик сигнала, который инвертирует 64-битное число. Это число используется в основной программе для проверки на атомарность.
   - Основной процесс многократно читает это число и проверяет, не является ли оно промежуточным состоянием (не все нули и не все единицы).
   
2. **Поведение на x86-32**:
   - На архитектуре x86-32 операция записи и чтения 64-битных чисел может требовать двух транзакций по шине, что приводит к состояниям, когда при извлечении данных можно получить половину старого значения и половину нового. Это и демонстрирует программа.
   
3. **Многопроцессность**:
   - Дочерний процесс отправляет сигналы родительскому процессу, заставляя его инвертировать значение переменной `ip`. Главная программа извлекает это значение и проверяет, является ли оно корректным (все нули или все единицы). Если извлечённое значение не соответствует этим критериям, выводится предупреждающее сообщение.

4. **Выводы**:
   - Этот код служит примером проблемы с атомарностью при работе с 64-битными целыми числами на архитектуре, где такие операции не являются атомарными, что может привести к ошибкам при многозадачности и многопроцессорности.
   */