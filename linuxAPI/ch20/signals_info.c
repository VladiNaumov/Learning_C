/* 20 Signals */

#include <signal.h>

/*
 * signal - устанавливает обработчик для сигнала.
 * 
 * sig - номер сигнала (например, SIGINT, SIGTERM и т.д.).
 * handler - указатель на функцию-обработчик, которая будет вызвана при получении сигнала.
 * 
 * Возвращает указатель на предыдущий обработчик для данного сигнала.
 */
void (*signal(int sig, void (*handler)(int)))(int);

/*
 * kill - посылает сигнал процессу.
 * 
 * pid - идентификатор процесса, которому посылается сигнал. Если pid == 0, сигнал отправляется всем процессам в группе.
 * sig - номер сигнала.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int kill(pid_t pid, int sig);

/*
 * raise - посылает сигнал текущему процессу.
 * 
 * sig - номер сигнала.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int raise(int sig);

/*
 * strsignal - возвращает строковое представление сигнала.
 * 
 * sig - номер сигнала.
 * 
 * Возвращает строку с названием сигнала (например, "SIGINT").
 */
#define _BSD_SOURCE
#include <signal.h>
extern const char *const sys_siglist[];

/*
 * strsignal - возвращает строковое представление сигнала (с дополнительными возможностями GNU).
 * 
 * sig - номер сигнала.
 * 
 * Возвращает строку с названием сигнала.
 */
#define _GNU_SOURCE
#include <string.h>
char *strsignal(int sig);

/*
 * psignal - выводит сообщение с текстом, связанным с сигналом.
 * 
 * sig - номер сигнала.
 * msg - строка с сообщением.
 * 
 * Функция выводит сообщение в стандартный поток ошибок, при этом также указывается текстовое описание сигнала.
 */
#include <signal.h>
void psignal(int sig, const char *msg);

/*
 * sigemptyset - инициализирует множество сигналов как пустое.
 * 
 * set - указатель на множество сигналов.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
#include <signal.h>
int sigemptyset(sigset_t *set);

/*
 * sigfillset - инициализирует множество сигналов как полное (все сигналы включены).
 * 
 * set - указатель на множество сигналов.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigfillset(sigset_t *set);

/*
 * sigaddset - добавляет сигнал в множество сигналов.
 * 
 * set - указатель на множество сигналов.
 * sig - номер сигнала, который добавляется.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
#include <signal.h>
int sigaddset(sigset_t *set, int sig);

/*
 * sigdelset - удаляет сигнал из множества сигналов.
 * 
 * set - указатель на множество сигналов.
 * sig - номер сигнала, который удаляется.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigdelset(sigset_t *set, int sig);

/*
 * sigismember - проверяет, включен ли сигнал в множество.
 * 
 * set - указатель на множество сигналов.
 * sig - номер сигнала.
 * 
 * Возвращает 1, если сигнал включен, и 0, если нет.
 */
#include <signal.h>
int sigismember(const sigset_t *set, int sig);

/*
 * sigandset - выполняет побитовую операцию "И" для двух множеств сигналов.
 * 
 * set - указатель на результат.
 * left - указатель на левое множество.
 * right - указатель на правое множество.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
#define _GNU_SOURCE
#include <signal.h>
int sigandset(sigset_t *set, sigset_t *left, sigset_t *right);

/*
 * sigorset - выполняет побитовую операцию "ИЛИ" для двух множеств сигналов.
 * 
 * set - указатель на результат.
 * left - указатель на левое множество.
 * right - указатель на правое множество.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);

/*
 * sigisemptyset - проверяет, является ли множество сигналов пустым.
 * 
 * set - указатель на множество сигналов.
 * 
 * Возвращает 1, если множество пусто, и 0 в противном случае.
 */
int sigisemptyset(const sigset_t *set);

/*
 * sigprocmask - изменяет маску сигналов для текущего процесса.
 * 
 * how - определяет, как должна изменяться маска сигналов (SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK).
 * set - указатель на множество сигналов, которое будет использоваться.
 * oldset - указатель на старую маску сигналов (можно передать NULL).
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

/*
 * sigpending - получает множество сигналов, которые в данный момент ожидают обработки.
 * 
 * set - указатель на множество сигналов.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigpending(sigset_t *set);

/*
 * sigaction - устанавливает обработчик для сигнала с возможностью сохранения старого обработчика.
 * 
 * sig - номер сигнала.
 * act - указатель на структуру sigaction с новым обработчиком.
 * oldact - указатель на структуру sigaction для сохранения старого обработчика.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
#include <signal.h>
int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);

/*
 * pause - приостанавливает выполнение текущего процесса до получения сигнала.
 * 
 * Функция возвращает -1 в случае ошибки.
 */
#include <unistd.h>
int pause(void);

/*
 Вот обновленный текст с добавленными пунктами:

Все эти функции работают с сигналами в Unix-подобных операционных системах.  
Сигналы представляют собой механизм асинхронной обработки событий, которые могут быть использованы для управления процессами.  
Некоторые функции позволяют устанавливать обработчики сигналов, посылать сигналы между процессами, манипулировать множествами сигналов  
(для блокировки или проверки наличия сигналов) и ожидать получения сигналов. Основной целью является эффективное управление асинхронными событиями в многозадачных системах.  

Дополнительно, функции позволяют:

1. **Управлять приоритетом обработки**: Например, с помощью `sigprocmask` можно временно блокировать сигналы, чтобы предотвратить их обработку в критические моменты выполнения программы, управляя приоритетом их обработки.

2. **Контролировать обработчики сигналов**: Функции вроде `signal` и `sigaction` обеспечивают гибкость в управлении обработчиками сигналов, позволяя устанавливать и сохранять старые обработчики, что полезно при сложной логике обработки сигналов.

3. **Использовать функции в зависимости от стандартов**: Некоторые функции, такие как `strsignal`, имеют расширения для разных стандартов (например, `_BSD_SOURCE`, `_GNU_SOURCE`), что дает дополнительные возможности в зависимости от требований проекта и системы.

Таким образом, эти функции позволяют не только управлять асинхронной обработкой сигналов, но и обеспечивают гибкость в их блокировке, приоритизации и настройке совместимости.
 */




/* 21 Signals: Signal Handlers (обработчики сигналов) */

#include <setjmp.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

int sigdelset(sigset_t *set, int sig);  // Удаляет сигнал из множества

/* Функция sigsetjmp сохраняет состояние выполнения в буфер
 * 
 * env - буфер, в котором сохраняется состояние выполнения.
 * savesigs - если ненулевое, сохраняются блокировки сигналов на момент вызова.
 * 
 * Возвращает 0 при первом вызове, и значение, переданное в siglongjmp(), при возвращении
 * через siglongjmp().
 */
int sigsetjmp(sigjmp_buf env, int savesigs) {
    // Сохраняет контекст выполнения, если savesigs ненулевое, то сохраняет блокировки сигналов
    return 0;
}

/* Функция siglongjmp восстанавливает состояние выполнения
 * 
 * env - буфер, в котором хранится сохранённое состояние.
 * val - значение, которое будет возвращено в sigsetjmp() после восстановления состояния.
 * 
 * Возвращает управление в точку, где была вызвана sigsetjmp(), с переданным значением val.
 */
void siglongjmp(sigjmp_buf env, int val) {
    // Восстанавливает сохраненный контекст выполнения, возвращает управление в точку вызова sigsetjmp
}

/* Функция abort завершает программу с ошибкой
 * 
 * Завершаем программу с ошибкой, никогда не возвращает управление.
 * Возвращает управление не может, так как программа завершится немедленно.
 */
void abort(void) {
    // Завершаем программу с ошибкой, никогда не возвращает управление
    exit(1);
}

/* Функция sigaltstack устанавливает альтернативный стек для сигналов
 * 
 * sigstack - указатель на структуру stack_t, которая описывает новый стек для сигналов.
 * old_sigstack - указатель на структуру stack_t, в которую будет записан старый стек, если он был.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigaltstack(const stack_t *sigstack, stack_t *old_sigstack) {
    // Устанавливаем альтернативный стек для обработки сигналов
    // sigstack — новый стек для сигналов, old_sigstack — старый стек, если он был
    return 0;
}

/* Функция siginterrupt управляет прерыванием системных вызовов сигналами
 * 
 * sig - сигнал, который будет использоваться для управления прерыванием системных вызовов.
 * flag - флаг, если ненулевое значение, системные вызовы не будут прерываться этим сигналом.
 * 
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int siginterrupt(int sig, int flag) {
    // Управляем прерыванием системных вызовов для заданного сигнала
    // sig — сигнал, flag — флаг (если ненулевое значение — вызовы не будут прерываться этим сигналом)
    return 0;
}

/*
Эти функции работают в контексте обработки сигналов и управления выполнением программы при возникновении сигналов. 
Они полезны для обеспечения устойчивости программы в многозадачных средах, где сигналы могут прерывать выполнение операций.
*/

/* 22 Signals: Advanced Features */

/* Signals - Additional Signal Handling Functions */

#define _GNU_SOURCE
#include <signal.h>

/*
 * sysv_signal - устаревшая версия функции для установки обработчика сигнала.
 *
 * sig - номер сигнала (например, SIGINT, SIGTERM).
 * handler - указатель на функцию-обработчик сигнала.
 *
 * Возвращает указатель на предыдущий обработчик сигнала.
 */
void (*sysv_signal(int sig, void (*handler)(int)))(int);

#define _POSIX_C_SOURCE 199309
#include <signal.h>

/*
 * sigqueue - посылает сигнал процессу вместе с дополнительными данными.
 *
 * pid - идентификатор процесса, которому посылается сигнал.
 * sig - номер сигнала.
 * value - дополнительные данные, которые будут переданы вместе с сигналом.
 *
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigqueue(pid_t pid, int sig, const union sigval value);

#define _POSIX_C_SOURCE 199309
#include <signal.h>

/*
 * sigsuspend - приостанавливает выполнение текущего процесса до получения сигнала.
 *
 * mask - маска сигналов, которые должны быть заблокированы во время ожидания.
 *
 * Возвращает -1 в случае ошибки, с errno = EINTR.
 */
int sigsuspend(const sigset_t *mask);

#define _POSIX_C_SOURCE 199309
#include <signal.h>

/*
 * sigwaitinfo - ожидает получения сигнала из заданного множества сигналов.
 *
 * set - множество сигналов, которые ожидаются.
 * info - структура siginfo_t для хранения информации о сигнале.
 *
 * Возвращает номер полученного сигнала, или -1 в случае ошибки.
 */
int sigwaitinfo(const sigset_t *set, siginfo_t *info);

#define _POSIX_C_SOURCE 199309
#include <signal.h>

/*
 * sigtimedwait - ожидает получение сигнала с тайм-аутом.
 *
 * set - множество сигналов, которые ожидаются.
 * info - структура siginfo_t для хранения информации о сигнале.
 * timeout - время ожидания в виде структуры timespec.
 *
 * Возвращает номер полученного сигнала или -1 в случае ошибки или истечения тайм-аута.
 */
int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);

#include <sys/signalfd.h>

/*
 * signalfd - создает файловый дескриптор, который можно использовать для ожидания сигналов.
 *
 * fd - дескриптор файла, куда будет записан сигнал.
 * mask - множество сигналов, которые должны быть заблокированы и ожидаться.
 * flags - флаги, определяющие поведение.
 *
 * Возвращает файловый дескриптор или -1 в случае ошибки.
 */
int signalfd(int fd, const sigset_t *mask, int flags);

#define _XOPEN_SOURCE 500
#include <signal.h>

/*
 * sigset - устаревшая версия функции для установки обработчика сигнала.
 *
 * sig - номер сигнала (например, SIGINT, SIGTERM).
 * handler - указатель на функцию-обработчик сигнала.
 *
 * Возвращает указатель на предыдущий обработчик сигнала.
 */
void (*sigset(int sig, void (*handler)(int)))(int);

#define _XOPEN_SOURCE 500
#include <signal.h>

/*
 * sighold - блокирует указанный сигнал, т.е. он не будет обработан до тех пор, пока его не разблокируют.
 *
 * sig - номер сигнала.
 *
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sighold(int sig);

/*
 * sigrelse - разблокирует указанный сигнал, чтобы его можно было обработать.
 *
 * sig - номер сигнала.
 *
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigrelse(int sig);

/*
 * sigignore - игнорирует указанный сигнал.
 *
 * sig - номер сигнала.
 *
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigignore(int sig);

/*
 * sigpause - приостанавливает выполнение процесса до получения сигнала, игнорируя текущие сигналы, кроме указанного.
 *
 * sigmask - маска сигналов.
 *
 * Возвращает -1 с errno = EINTR.
 */
int sigpause(int sigmask);

#define _BSD_SOURCE
#include <signal.h>

/*
 * sigvec - устаревшая версия функции для установки обработчика сигнала с дополнительными настройками.
 *
 * sig - номер сигнала.
 * vec - структура sigvec с настройками обработчика сигнала.
 * ovec - структура, в которую сохраняются старые настройки.
 *
 * Возвращает 0 в случае успеха или -1 в случае ошибки.
 */
int sigvec(int sig, struct sigvec *vec, struct sigvec *ovec);

#define _BSD_SOURCE
#include <signal.h>

/*
 * sigblock - блокирует множество сигналов.
 *
 * mask - маска сигналов.
 *
 * Возвращает предыдущую маску сигналов.
 */
int sigblock(int mask);

/*
 * sigsetmask - устанавливает маску сигналов.
 *
 * mask - новая маска сигналов.
 *
 * Возвращает предыдущую маску сигналов.
 */
int sigsetmask(int mask);

/*
 * sigpause - приостанавливает выполнение процесса до получения сигнала.
 *
 * sigmask - маска сигналов.
 *
 * Всегда возвращает -1 с errno = EINTR.
 */
int sigpause(int sigmask);

/*
 * sigmask - возвращает маску для конкретного сигнала.
 *
 * sig - номер сигнала.
 *
 * Возвращает маску сигнала.
 */
int sigmask(int sig);


/*
### Резюме по функционалу:

1. **sysv_signal()** и **sigset()** — устаревшие функции для установки обработчиков сигналов, обычно заменяются на более современный `sigaction()`.
2. **sigqueue()** — позволяет отправить сигнал с дополнительными данными в процесс.
3. **sigsuspend()**, **sigwaitinfo()**, и **sigtimedwait()** — функции для управления сигналами в процессе выполнения программы.
4. **signalfd()** — позволяет работать с сигналами как с файловыми дескрипторами, что полезно в многозадачных системах.
5. **sighold()**, **sigrelse()**, и **sigignore()** — устаревшие функции для управления блокировкой сигналов.
6. **sigpause()** — используется для приостановки процесса до получения сигнала, и возвращает -1 при прерывании сигнала.

Убедитесь, что используете актуальные и поддерживаемые функции для работы с сигналами, такие как `sigaction()` вместо устаревших методов.

*/

/*

### Современные и устаревшие функции для обработки сигналов

1. **Устаревшие функции**:
   - `sysv_signal()`, `sigset()`, `sigvec()` — эти функции были заменены более мощными и гибкими функциями, такими как `sigaction()`. Они уже не рекомендуются для использования в новых проектах, так как не предоставляют необходимого уровня контроля и надежности, особенно в многозадачных системах.
   
2. **Современные функции**:
   - `sigaction()` — основной инструмент для установки обработчиков сигналов. Он позволяет надежно настроить обработку сигналов с учетом возможности сохранить старый обработчик и использовать флаги, такие как `SA_RESTART` или `SA_SIGINFO`.
   
3. **Функции для отправки сигналов**:
   - `kill()`, `raise()`, `sigqueue()` — стандартные методы для отправки сигналов процессам. `sigqueue()` полезна, когда нужно отправить сигнал с дополнительными данными, например, с структурой `sigval`, которая может содержать целое число или указатель.

4. **Функции для работы с масками сигналов**:
   - `sigprocmask()`, `sigblock()`, `sigsetmask()` — используемые для блокировки сигналов. Эти функции полезны для управления тем, какие сигналы могут быть приняты процессом в конкретный момент времени.
   - `sigsuspend()`, `sigwaitinfo()`, `sigtimedwait()` — позволяют приостанавливать выполнение процесса, ожидая определенные сигналы. Эти функции полезны для синхронизации, особенно при работе с многозадачностью.

5. **Обработчики сигналов**:
   - `signal()`, `sigaction()` — позволяют установить функцию-обработчик для конкретного сигнала. Современный подход предпочитает `sigaction()` из-за его гибкости и возможностей, например, обработки сигнала с дополнительной информацией через `siginfo_t`.

6. **Альтернативный стек**:
   - `sigaltstack()` — позволяет назначить альтернативный стек для обработки сигналов, что может быть полезно для предотвращения переполнения стека в случае обработки слишком глубоких вложенных сигналов (например, при обработке переполнения стека самого процесса).

7. **Прерывание системных вызовов**:
   - `siginterrupt()` — контролирует, будет ли системный вызов прерван сигналом. Это полезно для обеспечения атомарности операций, которые не должны быть прерваны сигналами, например, при блокировке мьютексов.

8. **Специальные функции**:
   - `signalfd()` — позволяет использовать сигналы в качестве событий ввода-вывода, что удобно для работы с событийно-ориентированными архитектурами или в многозадачных приложениях.
   - `sigqueue()`, `sigwaitinfo()`, и `sigtimedwait()` — продвинутые функции для обработки сигналов с возможностью передачи дополнительной информации и установки тайм-аутов.

### Резюме
Большинство старых функций, таких как `signal()` и `sysv_signal()`, теперь считаются устаревшими и не рекомендуются к использованию в новых проектах. Рекомендуется использовать `sigaction()` для установки обработчиков сигналов и функции из POSIX, такие как `sigqueue()`, `sigwaitinfo()`, и `sigsuspend()`, для более сложной работы с сигналами и их блокировкой.

Для работы с многозадачными приложениями и асинхронными событиями использование сигналов остается важной частью архитектуры системы, позволяя управлять процессами, синхронизацией и обработкой исключений.

*/