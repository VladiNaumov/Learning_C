/* intquit.c

   Обработка сигналов SIGINT и SIGQUIT, которые обычно генерируются
   нажатием клавиш control-C (^C) и control-\ (^\) соответственно.

   Обратите внимание, что, хотя в этой программе для установки обработчиков сигналов
   используется signal(), предпочтительнее всегда использовать sigaction() для этой задачи.
*/
#include <signal.h>
#include "tlpi_hdr.h"

static void
sigHandler(int sig)
{
    static int count = 0;

    /* НЕБЕЗОПАСНО: Этот обработчик использует функции,
       небезопасные для асинхронных сигналов (printf(), exit(); см. Раздел 21.1.2) */

    if (sig == SIGINT) {
        count++;
        printf("Пойман SIGINT (%d)\n", count);
        return;                 /* Возобновить выполнение с места прерывания */
    }

    /* Должен быть SIGQUIT - выводим сообщение и завершаем процесс */

    printf("Пойман SIGQUIT - это всё, ребята!\n");
    exit(EXIT_SUCCESS);
}

int
main(int argc, char *argv[])
{
    /* Установить одинаковый обработчик для SIGINT и SIGQUIT. Здесь мы используем
       более простой API signal() для установки обработчика сигнала, но по причинам,
       описанным в Разделе 22.7 TLPI, sigaction() является
       (сильно) предпочтительным API для этой задачи. */

    if (signal(SIGINT, sigHandler) == SIG_ERR)
        errExit("signal");
    if (signal(SIGQUIT, sigHandler) == SIG_ERR)
        errExit("signal");

    for (;;)                    /* Бесконечный цикл, ожидание сигналов */
        pause();                /* Блокировка до тех пор, пока не будет пойман сигнал */
}

/*

### Резюме кода

Эта программа обрабатывает сигналы SIGINT и SIGQUIT, обычно генерируемые нажатием Ctrl+C и Ctrl+\ соответственно. 
При каждом нажатии Ctrl+C увеличивается счетчик обработок SIGINT, но выполнение программы продолжается. 
Нажатие Ctrl+\ вызывает обработку SIGQUIT, выводя сообщение и завершая программу. 
Программа использует функцию `signal()` для установки обработчиков, но предпочтительным является `sigaction()`, 
так как она предоставляет больше возможностей для управления сигналами.
*/