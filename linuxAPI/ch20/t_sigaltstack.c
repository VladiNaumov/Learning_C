/* t_sigaltstack.c

   Демонстрация использования sigaltstack() для обработки сигнала на альтернативном
   стеке сигналов.
*/
#define _GNU_SOURCE             /* Получаем объявление strsignal() из <string.h> */
#include <string.h>
#include <signal.h>
#include "tlpi_hdr.h"

static void
sigsegvHandler(int sig)
{
    int x;

    /* НЕБЕЗОПАСНО: Этот обработчик использует функции, не безопасные для асинхронных сигналов
       (printf(), strsignal(), fflush(); см. Раздел 21.1.2) */

    printf("Пойман сигнал %d (%s)\n", sig, strsignal(sig));
    printf("Верхняя часть стека обработчика находится по адресу %10p\n", (void *) &x);
    fflush(NULL);

    _exit(EXIT_FAILURE);                /* Нельзя вернуться после SIGSEGV */
}

/* Следующее останавливает 'gcc -Wall' от жалоб на "контроль достигает
   конца функции, не возвращая значения", потому что после вызова
   overflowStack() в main() не будет вызова exit(). */

#ifdef __GNUC__
static void
overflowStack(int callNum) __attribute__ ((__noreturn__));
#endif

static void             /* Рекурсивная функция, которая вызывает переполнение стека */
overflowStack(int callNum)
{
    char a[100000];                     /* Делаем этот фрейм стека большим */

    printf("Вызов %4d - верхняя часть стека рядом с адресом %10p\n", callNum, &a[0]);
    overflowStack(callNum+1);
}

int
main(int argc, char *argv[])
{
    stack_t sigstack;
    struct sigaction sa;
    int j;

    printf("Верхняя часть стандартного стека находится рядом с адресом %10p\n", (void *) &j);

    /* Выделяем альтернативный стек и уведомляем ядро о его существовании */

    sigstack.ss_sp = malloc(SIGSTKSZ);
    if (sigstack.ss_sp == NULL)
        errExit("malloc");

    sigstack.ss_size = SIGSTKSZ;
    sigstack.ss_flags = 0;
    if (sigaltstack(&sigstack, NULL) == -1)
        errExit("sigaltstack");
    printf("Альтернативный стек находится от %10p до %10p\n",
            sigstack.ss_sp, (char *) sbrk(0) - 1);

    sa.sa_handler = sigsegvHandler;     /* Устанавливаем обработчик для SIGSEGV */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_ONSTACK;           /* Обработчик использует альтернативный стек */
    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        errExit("sigaction");

    overflowStack(1);  /* Переполнение стека */
}
/*

### Резюме:
Этот код демонстрирует, как использовать альтернативный стек для обработки сигналов с помощью функции `sigaltstack()`. В частности, он показывает, как обработчик сигнала может быть запущен на альтернативном стеке для предотвращения переполнения стандартного стека при обработке сигналов.

1. **Основная логика**:
   - Программа создает альтернативный стек с помощью `sigaltstack()` и связывает его с обработчиком сигнала для SIGSEGV (ошибка сегментации). 
   - При возникновении SIGSEGV обработчик будет вызываться на этом альтернативном стеке, предотвращая переполнение стандартного стека.
   - В функции `overflowStack` происходит рекурсивный вызов, который имитирует переполнение стека.

2. **Особенности работы**:
   - Использование альтернативного стека через `sigaltstack()` позволяет обработчику сигнала выполняться на отдельном выделенном участке памяти, что полезно при глубоком рекурсивном вызове или при большом количестве данных на стеке.
   - В коде используется обработчик для сигнала SIGSEGV, чтобы показать, как программа обрабатывает сигнал с использованием альтернативного стека.
  
3. **Переполнение стека**:
   - Рекурсивная функция `overflowStack()` вызывает переполнение стека. Без использования альтернативного стека программа бы завершилась с ошибкой из-за исчерпания доступного пространства стека, однако, с альтернативным стеком, это предотвращается.
   */