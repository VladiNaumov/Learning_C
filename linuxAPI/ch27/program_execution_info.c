/* 27 Program Execution */

#include <unistd.h>

/*
 * execve - заменяет текущий процесс новым процессом, загружающим исполняемый файл по указанному пути.
 *
 * pathname - путь к исполняемому файлу.
 * argv - массив аргументов для нового процесса.
 * envp - массив переменных окружения для нового процесса.
 * Возвращает -1 в случае ошибки, иначе не возвращает (процесс замещен).
 */
int execve(const char *pathname, char *const argv[], char *const envp[]);

#include <unistd.h>

/*
 * execle - заменяет текущий процесс новым, используя переменные окружения, переданные в аргументах.
 *
 * pathname - путь к исполняемому файлу.
 * arg - первый аргумент для нового процесса, далее следует переменное число аргументов, 
 *       завершаемых NULL, и массив envp для окружения.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int execle(const char *pathname, const char *arg, ... /* , (char *) NULL, char *const envp[] */);

/*
 * execlp - аналогична execle, но ищет исполняемый файл в переменной окружения PATH.
 *
 * filename - имя исполняемого файла.
 * arg - первый аргумент для нового процесса, далее следует переменное число аргументов, 
 *       завершаемых NULL.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int execlp(const char *filename, const char *arg, ... /* , (char *) NULL */);

/*
 * execvp - аналогична execve, но ищет исполняемый файл в переменной окружения PATH.
 *
 * filename - имя исполняемого файла.
 * argv - массив аргументов для нового процесса.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int execvp(const char *filename, char *const argv[]);

/*
 * execv - аналогична execve, но использует переменные окружения текущего процесса.
 *
 * pathname - путь к исполняемому файлу.
 * argv - массив аргументов для нового процесса.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int execv(const char *pathname, char *const argv[]);

/*
 * execl - аналогична execle, но использует переменные окружения текущего процесса.
 *
 * pathname - путь к исполняемому файлу.
 * arg - первый аргумент для нового процесса, далее следует переменное число аргументов, 
 *       завершаемых NULL.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int execl(const char *pathname, const char *arg, ... /* , (char *) NULL */);

#define _GNU_SOURCE
#include <unistd.h>

/*
 * fexecve - выполняет execve, используя файловый дескриптор вместо пути.
 *
 * fd - файловый дескриптор открытого исполняемого файла.
 * argv - массив аргументов для нового процесса.
 * envp - массив переменных окружения для нового процесса.
 * Возвращает -1 в случае ошибки, иначе не возвращает.
 */
int fexecve(int fd, char *const argv[], char *const envp[]);

#include <stdlib.h>

/*
 * system - выполняет команду оболочки, переданную в виде строки.
 *
 * command - строка с командой для выполнения.
 * Возвращает код завершения команды или -1 при ошибке.
 */
int system(const char *command);


/*
С помощью вызова execve() процесс может заменить программу, которая в нем выполня-
ется, на новую. Этот вызов принимает списки аргументов (argv) и переменных среды для 
новой программы. Вокруг него существуют различные библиотечные функции-обертки, 
которые предоставляют разные интерфейсы к одним и тем же возможностям.
Все функции семейства exec() позволяют загружать бинарные исполняемые файлы 
или выполнять скрипты интерпретатора. В последнем случае его интерпретатор заменяет 
собой текущую программу процесса. Интерпретатор, а точнее, путь к нему обычно опре-
деляется первой строчкой скрипта (начинающейся с символов #!). Если такой строчки 
нет, скрипт может быть выполнен только с помощью функций execlp() или execvp(), 
которые используют в качестве интерпретатора командную оболочку.
Мы продемонстрировали, как с помощью сочетания вызовов fork(), exec(), exit() 
и wait() можно реализовать функцию system(), которая способна запускать произволь-
ные консольные команды.
*/

