/*
### Как работает SUID на низком уровне

Когда программа с установленным SUID-битом запускается, ядро ОС подменяет **действующий идентификатор пользователя** (Effective UID, eUID) процесса на **идентификатор владельца файла**.

#### Основные ID процесса в Unix

        У каждого процесса в Unix-системах есть несколько идентификаторов пользователя, которые влияют на его привилегии:
1. **Real UID (rUID)** — реальный UID, который определяет пользователя, запустившего процесс.
2. **Effective UID (eUID)** — действующий UID, который определяет текущие права доступа процесса.
3. **Saved Set-UID (sUID)** — сохранённый UID, который запоминает eUID для временного изменения прав и возврата обратно.

При запуске программы с SUID ядро копирует UID владельца файла в поле eUID процесса. Этот процесс позволяет программе исполняться с правами владельца файла, но сохраняет оригинальный rUID, который идентифицирует пользователя, запустившего программу.

### Последовательность действий при запуске программы с SUID

1. **Проверка прав доступа**:
- Когда пользователь запускает программу, система проверяет права на выполнение файла, включая наличие SUID.

2. **Изменение eUID**:
- Если SUID установлен, ядро меняет eUID процесса на UID владельца файла. Например, если файл принадлежит root (UID 0), то eUID процесса временно становится 0, давая ему права суперпользователя.

3. **Выполнение программы**:
- Программа исполняется с правами, заданными eUID, что даёт ей временные привилегии, необходимые для выполнения задач (например, доступ к системным файлам или операциям).

4. **Возврат к реальному пользователю**:
- После завершения работы программы система завершает процесс, и его временные привилегии исчезают.

### Пример с использованием SUID на уровне кода

        Рассмотрим ситуацию, когда программа использует SUID для выполнения привилегированных операций:

*/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Проверка текущих ID процесса
    printf("Real UID: %d\n", getuid());
    printf("Effective UID: %d\n", geteuid());

    // Доступ к защищенному ресурсу
    FILE *file = fopen("/etc/shadow", "r");
    if (file == NULL) {
        perror("Cannot open /etc/shadow");
        exit(1);
    }
    printf("File opened successfully\n");
    fclose(file);

    // Восстановление прав
    seteuid(getuid());  // Сброс eUID обратно к rUID
    printf("Privileges dropped, Effective UID: %d\n", geteuid());

    return 0;
}
/*
В этом примере:
- Если программа запускается с SUID root, то её eUID временно становится 0, и она получает доступ к `/etc/shadow`.
- После выполнения привилегированной операции программа сбрасывает eUID, чтобы минимизировать риски, возвращая привилегии исходного пользователя.

### Риски SUID

Если программа с SUID имеет уязвимости (например, переполнение буфера), злоумышленник может получить eUID root и использовать его для выполнения команд с правами суперпользователя. Поэтому:
- SUID-программы должны быть минимально сложными и безопасными.
- Рекомендуется сбрасывать eUID сразу после выполнения привилегированных операций.

Таким образом, SUID — это способ временно передавать привилегии процессу на уровне ядра, обеспечивая доступ к защищённым ресурсам без полного повышения прав для пользователя, запускающего программу.
*/