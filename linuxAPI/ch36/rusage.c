/* rusage.c

   Выполняет указанную команду и выводит сводку по использованным ресурсам
   (как извлечено через getrusage()).

   Также см. print_rusage.c для реализации printRusage().
*/

#include <sys/resource.h>
#include <sys/wait.h>
#include "print_rusage.h"    /* Заголовочный файл для printRusage */
#include "tlpi_hdr.h"

int main(int argc, char *argv[])
{
    pid_t childPid;        /* Идентификатор процесса дочернего процесса */
    struct rusage ru;      /* Структура для хранения данных о ресурсах */

    /* Проверяем наличие аргументов */
    if (argc < 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s command arg...\n", argv[0]);

    /* Создаем новый процесс */
    switch (childPid = fork()) {
    case -1:
        errExit("fork");   /* Ошибка при создании дочернего процесса */

    case 0:               /* Дочерний процесс */
        execvp(argv[1], &argv[1]); /* Выполняем команду с аргументами */
        errExit("execvp");         /* Если execvp() не завершится успешно */

    default:              /* Родительский процесс */
        printf("Command PID: %ld\n", (long) childPid); /* Выводим PID команды */
        if (wait(NULL) == -1)                          /* Ожидаем завершения дочернего процесса */
            errExit("wait");
        if (getrusage(RUSAGE_CHILDREN, &ru) == -1)     /* Получаем ресурсы дочернего процесса */
            errExit("getrusage");

        printf("\n");
        printRusage("\t", &ru); /* Выводим информацию о ресурсах */
        exit(EXIT_SUCCESS);     /* Завершаем родительский процесс */
    }
}


/*
### Резюме:

**Описание:**
Код выполняет указанную команду (переданную через аргументы программы), ожидает завершения её выполнения и выводит информацию о ресурсах, использованных дочерним процессом. Для этого используется системный вызов `getrusage()` с флагом `RUSAGE_CHILDREN`.

---

**Основные этапы работы:**
1. **Проверка аргументов командной строки:**  
   Убедиться, что команда для выполнения передана. Если аргументы отсутствуют или указан `--help`, выводится справка по использованию.

2. **Создание дочернего процесса:**  
   Используется `fork()` для создания нового процесса:
   - В дочернем процессе вызывается `execvp()` для выполнения команды.
   - Если `execvp()` завершается с ошибкой, процесс завершает работу с сообщением об ошибке.

3. **Ожидание завершения команды:**  
   Родительский процесс использует `wait()` для ожидания завершения дочернего процесса.

4. **Получение статистики ресурсов:**  
   После завершения дочернего процесса, родительский процесс вызывает `getrusage()` для получения информации об использованных ресурсах (время процессора, память и т. д.).

5. **Вывод статистики:**  
   Используется функция `printRusage()` для форматированного вывода информации о ресурсах.

---

**Используемые функции:**
- `fork()` — для создания нового процесса.
- `execvp()` — для выполнения команды в дочернем процессе.
- `wait()` — для ожидания завершения дочернего процесса.
- `getrusage()` — для получения статистики использования ресурсов дочерним процессом.
- `printRusage()` — выводит данные о ресурсах в удобочитаемом формате.

---

**Назначение:**
Программа полезна для мониторинга производительности команд, выполнения профилирования или анализа использования ресурсов любым выполняемым процессом.

*/