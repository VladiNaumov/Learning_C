/* 28 Process Creation and Program Execution in More Detail */

#define _BSD_SOURCE
#include <unistd.h>

/*
 * acct - включает или выключает ведение учёта процессов.
 *
 * acctfile - путь к файлу учёта. Если NULL, учёт отключается.
 * Возвращает 0 в случае успеха, или -1 при ошибке.
 */
int acct(const char *acctfile);

#define _GNU_SOURCE
#include <sched.h>

/*
 * clone - создает новый процесс или поток, используя указанные параметры.
 *
 * func - указатель на функцию, выполняемую в новом процессе или потоке.
 * child_stack - указатель на стек, используемый новым процессом или потоком.
 * flags - флаги, определяющие поведение нового процесса или потока (например, CLONE_VM, CLONE_FS).
 * func_arg - аргумент, передаваемый в функцию func.
 * Дополнительные параметры:
 *   ptid - указатель на pid_t, в который записывается идентификатор родительского процесса.
 *   tls - указатель на структуру user_desc, устанавливающую TLS для нового потока.
 *   ctid - указатель на pid_t, в который записывается идентификатор дочернего процесса.
 * Возвращает идентификатор дочернего процесса в случае успеха, или -1 при ошибке.
 */
int clone(int (*func)(void *), void *child_stack, int flags, void *func_arg, ... /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */);


/*

Добавить можно такие детали:  

1. **`acct`**  
   - Указать, что файл учёта содержит информацию о завершённых процессах, включая потреблённые ресурсы (CPU время, память и т. д.).  
   - Подчеркнуть, что файл учёта создаётся в бинарном формате и анализируется специальными инструментами, например, `lastcomm`.

2. **`clone`**  
   - Упомянуть, что `clone` позволяет гибко контролировать степень изоляции нового процесса от родительского, что делает его базовым инструментом для реализации потоков (например, `pthread` в Linux).  
   - Подчеркнуть, что `child_stack` должен указывать на нижний конец стека, так как стек в Linux растёт "вниз".  
   - Указать, что вызов `clone` — это низкоуровневая альтернатива `fork` для специализированных случаев, таких как создание контейнеров или потоков.  

Если добавить эти детали, получится более полное описание. Хотите обновить описание?

*/


/*
Когда включен учет ресурсов, ядро записывает в файл учетные сведения о каждом за-
вершающемся процессе в системе.
По аналогии с fork(), системный вызов clone() (доступный только в Linux) создает 
новый процесс, но при этом позволяет более тонко управлять разделением атрибутов
между родителем и потомком. Он в основном используется для реализации поточных 
библиотек.
Мы сравнили скорость создания процессов с помощью fork(), vfork() и clone(). 
Вызов vfork() опережает fork() по скорости, однако разница между этими системными 
вызовами небольшая, если сравнивать с временем, которое уходит у потомка на выпол-
нение последующего вызова exec().
Дочерний процесс, созданный с помощью вызова fork(), наследует копии (или в не-
которых случаях разделяет) определенные атрибуты своего родителя. Например, потомок 
наследует от родителя копии таблицы файловых дескрипторов и действия сигналов, но 
не интервалы таймеров, блокировки записей или набор ожидающих сигналов. Соответ-
ственно, когда процесс выполняет exec(), одни его атрибуты остаются без изменений, 
а другие сбрасываются к значениям по умолчанию. Например, идентификатор процесса 
сохраняется прежним, файловые дескрипторы остаются открытыми (если не указан флаг 
FD_CLOEXEC), интервалы таймеров не меняются, а сигналы остаются в режиме ожидания; 
однако обрабатываемые сигналы сбрасывают свои действия к значениям по умолчанию, 
а сегменты общей памяти разъединяются.

*/