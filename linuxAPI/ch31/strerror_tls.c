/* strerror_tls.c

   Реализация функции strerror(), которая является потокобезопасной
   благодаря использованию локального хранилища потока (TLS).

   Смотрите также strerror_tsd.c.

   Требования: Linux 2.6 или новее, NPTL, gcc 3.3 или новее.
*/

#define _GNU_SOURCE  /* Подключает '_sys_nerr' и '_sys_errlist' из <stdio.h> */
#include <stdio.h>
#include <string.h>   /* Подключает объявление strerror() */
#include <pthread.h>

#define MAX_ERROR_LEN 256  /* Максимальная длина строки, возвращаемой strerror() */

/* 
 * Локальный для потока буфер, который используется для хранения строки,
 * возвращаемой strerror().
 */
static __thread char buf[MAX_ERROR_LEN];

/* 
 * strerror: Возвращает строку с описанием ошибки на основе её кода.
 * 
 * Потокобезопасная реализация благодаря использованию локального хранилища потока (TLS).
 * 
 * Параметры:
 *   err - код ошибки.
 * 
 * Возвращает:
 *   Указатель на строку с описанием ошибки, локальную для текущего потока.
 */
char *strerror(int err) {
    /* Формируем строку описания ошибки */
    if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL) {
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '\0';  /* Гарантируем нуль-терминацию */
    }

    return buf;
}

/* 
 * Резюме:
 * 
 * Данная реализация strerror() использует локальное хранилище потока (Thread-Local Storage, TLS),
 * что делает её потокобезопасной. У каждого потока есть собственный буфер `buf`, который
 * не делится с другими потоками. Это позволяет избежать конфликтов при одновременных вызовах
 * strerror() из разных потоков.
 * 
 * Преимущества:
 * - Простота реализации.
 * - Автоматическое управление памятью благодаря TLS.
 * 
 * Недостатки:
 * - Требует поддержки TLS со стороны компилятора и системы.
 */
