/* t_setsid.c

   Демонстрация использования setsid(2) для начала новой сессии.
*/

#if !defined(_XOPEN_SOURCE) || _XOPEN_SOURCE < 500
#define _XOPEN_SOURCE 500
#endif
#include <unistd.h>
#include <fcntl.h>
#include "tlpi_hdr.h"

int main(int argc, char *argv[])
{
    // Если это родительский процесс, завершить выполнение
    if (fork() != 0)            /* Выход для родительского процесса или при ошибке */
        _exit(EXIT_SUCCESS);

    // Создаем новую сессию
    if (setsid() == -1)
        errExit("setsid");

    // Выводим идентификаторы текущего процесса, группы процессов и сессии
    printf("PID=%ld, PGID=%ld, SID=%ld\n", (long) getpid(),
            (long) getpgrp(), (long) getsid(0));

    // Следующий вызов должен завершиться с ошибкой, так как нет управляющего терминала
    if (open("/dev/tty", O_RDWR) == -1)
        errExit("open /dev/tty");

    exit(EXIT_SUCCESS);
}

/*
 * Резюме:
 *
 * - Программа демонстрирует использование системного вызова `setsid` для создания новой сессии.
 * - Новый процесс, созданный через `fork`, становится лидером новой сессии и группы процессов,
 *   не имея управляющего терминала.
 * - После вызова `setsid` программа проверяет отсутствие управляющего терминала, пытаясь открыть
 *   `/dev/tty`, что ожидаемо приводит к ошибке.
 *
 * Основная цель кода — показать, как сессия может быть изолирована от терминала.
 */

