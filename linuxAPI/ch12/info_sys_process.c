/* 12 System and Process Information */

/*
Рассматриваются способы получения различной информации о системе
и процессе. Основное внимание в ней уделяется файловой системе /proc. Кроме того,
дается описание системного вызова uname(), используемого для извлечения различных
идентификаторов системы.
 */

#include <sys/utsname.h>
int uname(struct utsname * utsbuf );

/* Функция `uname` заполняет структуру `utsname` информацией о текущей операционной системе и оборудовании. Она используется для получения данных, таких как имя операционной системы, имя узла, версия ядра и другие системные характеристики.

### Структура `utsname`
Структура `utsname` обычно выглядит так:

struct utsname {
    char sysname[];    // Название операционной системы
    char nodename[];   // Имя узла в сети
    char release[];    // Версия ядра
    char version[];    // Дополнительная версия ядра
    char machine[];    // Аппаратная платформа (архитектура)
};


### Возвращаемое значение
- Успешное выполнение: возвращает `0`.
- При ошибке: возвращает `-1` и устанавливает значение `errno` для указания типа ошибки.

### Пример использования
Пример показывает, как можно использовать `uname` для вывода информации о системе.

*/

#include <stdio.h>
#include <sys/utsname.h>

int main() {
    struct utsname sys_info;
    
    // Вызов uname для получения системной информации
    if (uname(&sys_info) == 0) {
        printf("System Name:    %s\n", sys_info.sysname);
        printf("Node Name:      %s\n", sys_info.nodename);
        printf("Release:        %s\n", sys_info.release);
        printf("Version:        %s\n", sys_info.version);
        printf("Machine:        %s\n", sys_info.machine);
    } else {
        perror("uname error");
    }

    return 0;
}

/*
### Описание примера
- Функция `uname` вызывается с указателем на `sys_info`, который будет заполнен системной информацией.
- Если `uname` выполнится успешно, программа выведет информацию о системе.
- При ошибке будет показано сообщение об ошибке с помощью `perror`. 

Этот код может быть полезен для диагностики или для проверки системной совместимости перед выполнением операций.
*/

/*
Да, во всех приведённых задачах (find_opened_proces, list_user_process, process_tree) 

мы использовали файловую систему `/proc`, так как она предоставляет актуальную информацию о процессах и системе в Linux. Файловая система `/proc` содержит различные виртуальные файлы, через которые можно получить информацию о процессах, включая их идентификаторы, иерархию, открытые файлы, и множество других данных. Она не хранит реальные файлы, а динамически отображает информацию, поддерживаемую ядром Linux.

Вот как мы использовали `/proc` в задачах:

1. **Для получения информации о системе и процессе**:
   - Мы использовали `/proc/PID/status` для доступа к `PPid` (родительскому процессу) и `Name` (имени процесса), чтобы построить иерархию процессов.

2. **Для нахождения процессов, открывших конкретный файл**:
   - Мы просматривали символьные ссылки в каталогах `/proc/PID/fd/`, чтобы проверить, открыт ли конкретный файл процессом.

3. **Для настройки параметров системы**:
   - В одной из задач мы изменяли значение в `/proc/sys/kernel/pid_max` для изменения максимального PID, который может быть назначен новому процессу.

4. **Для извлечения идентификаторов и команд всех процессов пользователя**:
   - Мы использовали `/proc/[PID]/status`, чтобы получить идентификатор пользователя (UID) и название процесса.

`/proc` — это мощный инструмент, особенно полезный для системного программирования и администрирования, поскольку предоставляет подробные и обновляемые данные о процессах и системных ресурсах, напрямую взаимодействуя с ядром Linux.

*/