
/* dnotify.c

   Демонстрация использования устаревшей функции dnotify для получения уведомлений об изменениях в каталоге.
   (Современные программы должны использовать inotify вместо dnotify. API inotify доступен в Linux начиная с версии 2.6.13.)

   Пример использования, как показано в usageError() ниже. Пример:

        dnotify dir1:a xyz/dir2:acdM

   Смотрите также demo_inotify.c.

   Эта программа специфична для Linux.
*/


#define _GNU_SOURCE             /* Для получения констант DN_* из <fcntl.h> */
#include <fcntl.h>
#include <signal.h>
#include "tlpi_hdr.h"

// Функция для вывода сообщения об ошибке и информации по использованию программы
static void usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s", msg);

    fprintf(stderr, "Usage: %s directory:[events]...\n", progName);
    fprintf(stderr, "    Events are:\n"
        "        a - access; A - attrib; c - create; d - delete\n"
        "        m - modify; r - rename; M - multishot\n"
        "        (по умолчанию все события)\n");
    exit(EXIT_FAILURE);
}

// Обработчик сигнала для уведомлений о событиях в каталоге
static void handler(int sig, siginfo_t *si, void *ucontext)
{
    printf("Получено событие на дескрипторе %d\n", si->si_fd); 
                        /* ОПАСНО (см. Раздел 21.1.2) */
}

int main(int argc, char *argv[])
{
    if (argc < 2 || strcmp(argv[1], "--help") == 0)
        usageError(argv[0], NULL);

    // Устанавливаем обработчик для сигнала уведомления
    const int NOTIFY_SIG = SIGRTMIN;

    struct sigaction sa;
    sa.sa_sigaction = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_SIGINFO;           /* Для передачи аргумента siginfo_t в обработчик. */
    if (sigaction(NOTIFY_SIG, &sa, NULL) == -1)
        errExit("sigaction");

    // Обрабатываем аргументы командной строки
    for (int fnum = 1; fnum < argc; fnum++) {
        int events;
        char *p = strchr(argv[fnum], ':');  /* Ищем опциональный ':' */

        if (p == NULL) {  /* По умолчанию все события + multishot */
            events = DN_ACCESS | DN_ATTRIB | DN_CREATE | DN_DELETE |
                     DN_MODIFY | DN_RENAME | DN_MULTISHOT;
        } else {  /* Если есть ':', парсим символы событий */
            *p = '\0';  /* Завершаем компонент каталога */
            events = 0;
            for (p++; *p != '\0'; p++) {
                switch (*p) {
                case 'a': events |= DN_ACCESS;          break;
                case 'A': events |= DN_ATTRIB;          break;
                case 'c': events |= DN_CREATE;          break;
                case 'd': events |= DN_DELETE;          break;
                case 'm': events |= DN_MODIFY;          break;
                case 'r': events |= DN_RENAME;          break;
                case 'M': events |= DN_MULTISHOT;       break;
                default:  usageError(argv[0], "Некорректный символ события\n");
                }
            }
        }

        // Получаем дескриптор для каталога, который будем отслеживать
        int fd = open(argv[fnum], O_RDONLY);
        if (fd == -1)
            errExit("open");
        printf("Открыт каталог '%s' с дескриптором %d\n", argv[fnum], fd);

        // Используем альтернативный сигнал вместо SIGIO для уведомлений dnotify
        if (fcntl(fd, F_SETSIG, NOTIFY_SIG) == -1)
            errExit("fcntl - F_SETSIG");

        // Включаем уведомления об изменениях в каталоге
        if (fcntl(fd, F_NOTIFY, events) == -1)
            errExit("fcntl-F_NOTIFY");
        printf("События: %o\n", (unsigned int) events);
    }

    // Ожидаем событий в бесконечном цикле
    for (;;)
        pause();  /* Ожидание событий */
}
/*

### Объяснение:

1. **`usageError`** — эта функция выводит ошибку и информацию о том, как использовать программу, а затем завершает выполнение.
   - Если аргументы командной строки некорректны или вызывается `--help`, программа выводит справку.

2. **`handler`** — обработчик сигнала. Когда происходит событие, связанное с каталогом, система вызывает этот обработчик, который выводит информацию о дескрипторе файла, вызвавшем событие.

3. **Обработчик событий**:
   - `inotify` использует сигналы для уведомления о событиях. Здесь применяется сигнал `SIGRTMIN`, который передается обработчику с информацией о событии через структуру `siginfo_t`.

4. **Парсинг аргументов командной строки**:
   - Программа принимает аргументы, которые задают каталог и набор событий, которые нужно отслеживать. Если события не указаны, по умолчанию отслеживаются все события: доступ, атрибуты, создание, удаление, изменение и т. д.

5. **Работа с файловыми дескрипторами**:
   - Для каждого каталога, который передается в программу, открывается файловый дескриптор, с помощью которого включаются уведомления о событиях. Этот дескриптор используется с функцией `fcntl()` для установки событий, на которые программа будет реагировать.

6. **Ожидание событий**:
   - Программа завершает выполнение в бесконечном цикле `pause()`, ожидая уведомлений. Когда событие происходит, система сигнализирует программе с помощью установленного сигнала, и вызывается обработчик.

### Важные моменты:
- **Использование dnotify** — Этот подход уже устарел, и современные программы должны использовать `inotify`, который более эффективен и поддерживает больше возможностей.
- **Важность правильной настройки сигналов** — Важно правильно настроить обработчики сигналов, чтобы система могла уведомить о событиях, происходящих в отслеживаемых каталогах.

Этот код демонстрирует работу с устаревшей системой уведомлений `dnotify`, которую следует избегать при разработке новых программ. Вместо нее следует использовать `inotify`, как показано в другом примере.

*/