/* make_zombie.c

   Демонстрация того, как дочерний процесс становится зомби в интервале между
   моментом его завершения и моментом, когда родитель вызывает wait() (или завершится сам,
   в таком случае процесс будет принят init(8), который выполнит wait и освободит зомби).
*/

#include <signal.h>
#include <libgen.h>             /* Для объявления basename() */
#include "tlpi_hdr.h"

#define CMD_SIZE 200

int
main(int argc, char *argv[])
{
    char cmd[CMD_SIZE];       /* Буфер для команды для просмотра статуса процесса */
    pid_t childPid;           /* PID дочернего процесса */

    setbuf(stdout, NULL);       /* Отключаем буферизацию stdout */

    printf("Parent PID=%ld\n", (long) getpid());  /* Выводим PID родительского процесса */

    switch (childPid = fork()) {
    case -1:
        errExit("fork");        /* Ошибка при создании дочернего процесса */

    case 0:     /* Дочерний процесс: немедленно завершает выполнение и становится зомби */
        printf("Child (PID=%ld) exiting\n", (long) getpid());
        _exit(EXIT_SUCCESS);    /* Завершаем дочерний процесс */

    default:    /* Родительский процесс */
        sleep(3);               /* Даем дочернему процессу время для старта и завершения */
        snprintf(cmd, CMD_SIZE, "ps | grep %s", basename(argv[0]));  /* Формируем команду для отображения процессов */
        system(cmd);            /* Выполняем команду для просмотра зомби-процесса */

        /* Отправляем "гарантированное убийство" зомби-процессу */

        if (kill(childPid, SIGKILL) == -1)
            errMsg("kill");     /* Отправка сигнала SIGKILL для завершения процесса */
        sleep(3);               /* Даем дочернему процессу время на реакцию */
        printf("After sending SIGKILL to zombie (PID=%ld):\n", (long) childPid);
        system(cmd);            /* Просматриваем статус процесса снова */

        exit(EXIT_SUCCESS);     /* Завершаем выполнение родительского процесса */
    }
}
/*

### Резюме кода

Программа демонстрирует, как дочерний процесс становится зомби. 
Это происходит в интервале времени между его завершением и моментом, когда родитель вызывает `wait()` для очистки его состояния. 
Программа создает дочерний процесс, который сразу завершает свою работу, становясь зомби. 
Родительский процесс ждет 3 секунды, чтобы дать дочернему процессу время завершиться, и затем использует команду `ps` для отображения зомби-процесса. 
Далее родитель отправляет дочернему процессу сигнал `SIGKILL` для принудительного завершения, и снова выводит статус процесса, чтобы показать, что зомби был удален.
*/