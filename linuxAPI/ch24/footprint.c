Вот обновленный код с переводом комментариев и добавленными пояснениями для ясности:
/* footprint.c

   Использование fork() и wait() для контроля памяти приложения.

   Эта программа содержит функцию, которая (искусственно) потребляет большое
   количество памяти. Чтобы избежать изменения объема памяти процесса,
   программа создает дочерний процесс, который вызывает эту функцию. После завершения
   дочернего процесса, вся его память освобождается, и потребление памяти родительским
   процессом остается неизменным.
*/

#define _BSD_SOURCE     /* Для получения декларации sbrk() из <unistd.h>,
                           если _XOPEN_SOURCE >= 600; определение _SVID_SOURCE или
                           _GNU_SOURCE также подходит */

#include <sys/wait.h>
#include "tlpi_hdr.h"

static int
func(int arg)
{
    int j;

    /* Потребление большого количества памяти */
    for (j = 0; j < 0x100; j++)
        if (malloc(0x8000) == NULL)   /* Выделение памяти */
            errExit("malloc");
    printf("Program break in child:  %10p\n", sbrk(0)); /* Вывод "програмного разрыва" в дочернем процессе */

    return arg;
}

int
main(int argc, char *argv[])
{
    int arg = (argc > 1) ? getInt(argv[1], 0, "arg") : 0;  /* Получаем аргумент командной строки */
    pid_t childPid;
    int status;

    setbuf(stdout, NULL);           /* Отключение буферизации stdout */

    printf("Program break in parent: %10p\n", sbrk(0));  /* Вывод "програмного разрыва" в родительском процессе */

    childPid = fork();
    if (childPid == -1)
        errExit("fork");

    if (childPid == 0)              /* Дочерний процесс вызывает func() и */
        exit(func(arg));            /* использует возвращаемое значение как статус завершения */

    /* Родитель ждет завершения дочернего процесса. Он может определить результат func()
       путем анализа переменной 'status' */

    if (wait(&status) == -1)
        errExit("wait");

    printf("Program break in parent: %10p\n", sbrk(0));  /* Вывод "програмного разрыва" в родительском процессе */

    printf("Status = %d %d\n", status, WEXITSTATUS(status));  /* Вывод статуса завершения дочернего процесса */

    exit(EXIT_SUCCESS);
}
/*
### Резюме кода
Программа демонстрирует, как можно контролировать потребление памяти с помощью `fork()` и `wait()`. 
Она создает дочерний процесс, который выполняет функцию, потребляющую большое количество памяти с использованием `malloc`. 
Родительский процесс не испытывает изменения в объеме своей памяти, поскольку все изменения происходят в дочернем процессе. 
После завершения дочернего процесса, его память освобождается, и родительский процесс продолжает выполнение без изменений в своем потреблении памяти. 
Код использует `sbrk(0)`, чтобы показать "программный разрыв" в обоих процессах до и после вызова `fork()`.
*/