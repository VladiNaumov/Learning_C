/* t_vfork.c

   Демонстрация использования vfork() для создания дочернего процесса.
*/

#define _BSD_SOURCE     /* Чтобы получить объявление vfork() из <unistd.h>
                           в случае, если _XOPEN_SOURCE >= 700 */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int istack = 222; // Инициализируем переменную в стеке родительского процесса

    // Создаем дочерний процесс с помощью vfork()
    switch (vfork()) {
    case -1:
        errExit("vfork"); // Сообщение об ошибке, если вызов vfork завершился неудачей

    case 0:             
        // Дочерний процесс выполняется первым в адресном пространстве родителя
        sleep(3);       // Пауза для демонстрации того, что родитель не выполняется, пока дочерний процесс не завершится
        write(STDOUT_FILENO, "Child executing\n", 16);
        istack *= 3;    // Изменение переменной в дочернем процессе, оно будет видно родителю
        _exit(EXIT_SUCCESS); // Завершаем дочерний процесс, освобождая родителя

    default:            
        // Родитель продолжает выполнение после завершения дочернего процесса
        write(STDOUT_FILENO, "Parent executing\n", 17);
        printf("istack=%d\n", istack); // Выводим значение переменной, измененной дочерним процессом
        exit(EXIT_SUCCESS); // Завершаем родительский процесс
    }
}

/*

### Резюме кода
Этот код показывает работу `vfork()`, который создает дочерний процесс, временно блокируя выполнение родительского. 
Дочерний процесс использует память родителя и изменяет значение переменной `istack`, которая инициализирована родителем. 
После завершения дочернего процесса родитель продолжает выполнение и видит изменение в `istack`, 
так как `vfork()` позволяет дочернему процессу работать в том же адресном пространстве, что и родитель.
*/