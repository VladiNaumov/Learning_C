/* t_fork.c

   Демонстрация использования fork(), показывающая, что родительский и дочерний
   процессы получают отдельные копии сегментов стека и данных.
*/

#include "tlpi_hdr.h"

static int idata = 111;             // Переменная, выделенная в сегменте данных

int
main(int argc, char *argv[])
{
    int istack = 222;               // Переменная, выделенная в сегменте стека
    pid_t childPid;

    // Создаем дочерний процесс с помощью fork()
    switch (childPid = fork()) {
    case -1:
        errExit("fork"); // Сообщение об ошибке, если вызов fork завершился неудачей

    case 0:
        // Дочерний процесс: изменяет значения переменных
        idata *= 3;
        istack *= 3;
        break;

    default:
        sleep(3);                   // Родитель приостанавливается, чтобы дочерний процесс мог выполниться
        break;
    }

    /* И родитель, и дочерний процесс продолжают выполнение здесь */

    printf("PID=%ld %s idata=%d istack=%d\n", (long) getpid(),
            (childPid == 0) ? "(child) " : "(parent)", idata, istack);

    exit(EXIT_SUCCESS);
}
/*
### Резюме кода
Этот код демонстрирует работу функции `fork()`, которая создает дочерний процесс с отдельными копиями сегментов данных и стека. 
Переменная `idata`, находящаяся в сегменте данных, и `istack`, находящаяся в сегменте стека, копируются для дочернего процесса. 
В дочернем процессе значения этих переменных изменяются. 
После завершения дочернего процесса родительский процесс выполняется и выводит исходные значения, показывая, 
что изменения в дочернем процессе не затрагивают данные родителя.
*/