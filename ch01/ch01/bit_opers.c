/*
Начнем с самой простой битовой операции НЕ, которая выполняет 
инверсию бит в соответствии со следующей таблицей истинности:
*/

#include <stdio.h>

int main(void)
{
unsigned char var = 153;  //двоичная запись 10011001
unsigned char not_v = ~var; //результат:    01100110 (число 102)

printf("var = %d, not_v = %d\n", var, not_v);

return 0;
}

/*

Битовая операция И
Следующая операция битовая И в языке Си записывается символом & (амперсанд).

Это очень похоже на умножение, поэтому ее условно воспринимают, как 
битовое умножение.

00000101
00000100
========
00000100
*/

#include <stdio.h>

int main(void)
{
unsigned char flags = 5;  //двоичная запись 00000101
unsigned char mask = 4;   //двоичная запись 00000100

unsigned char res = flags & mask;

printf("res = %d\n", res);

return 0;
}

/*
    Битовая операция ИЛИ
Следующая битовая операция – битовое ИЛИ. 
Она определяется символом | и это своеобразное битовое сложение.

00001000
00000101
========
00001101

*/
#include <stdio.h>

int main(void)
{
unsigned char flags = 8;  //двоичная запись 00001000
unsigned char mask = 5;   //двоичная запись 00000101

flags = flags | mask;       //двоичная запись 00001101 (число 13)

printf("flags = %d\n", flags);

return 0;
}


/*
       (XOR) Битовая операция исключающее ИЛИ
И последняя базовая операция работы с битами – исключающее ИЛИ 
(ее еще называют XOR). Она определяется символом ^ 

коротко, если при сравнение двух бит они одинаковы, то будет 0
если разные, то 1

00001001
00000001
========
00001000

*/


#include <stdio.h>

int main(void)
{
unsigned char flags = 9;  //двоичная запись 00001001
unsigned char mask = 1;   //двоичная запись 00000001

flags = flags ^ mask;     //двоичная запись 00001000 (число 8)

printf("flags = %d\n", flags);

flags ^= mask;     //двоичная запись 00001001 (число 9)
printf("flags = %d\n", flags);

return 0;
}




