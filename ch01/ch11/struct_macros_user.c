/* Представим, что у нас есть простая программа, которая работает с объектами (например, с User),
и мы хотим сделать макрос для получения текущего пользователя (аналогия с текущим процессом).*/

#include <stdio.h>

#define CURRENT_USER() (&current_user)

struct User {
    int id;
    const char *name;
};

struct User current_user = {1, "Alice"};  // Глобальная переменная, представляющая текущего пользователя

void print_current_user_info() {
    struct User *user = CURRENT_USER();  // Используем макрос для получения текущего пользователя
    printf("Current user ID: %d\n", user->id);
    printf("Current user name: %s\n", user->name);
}

int main() {
    print_current_user_info();
    return 0;
}
/*
Объяснение:
CURRENT_USER() — это макрос, который возвращает указатель на глобальную переменную current_user. По сути, макрос просто подставляет выражение (&current_user) вместо себя при компиляции.

struct User — простая структура, представляющая пользователя с полями id и name.

current_user — глобальная переменная, которая хранит информацию о текущем пользователе (аналогично тому, как task_struct хранит информацию о текущем процессе в ядре Linux).

В функции print_current_user_info(), макрос CURRENT_USER() используется для получения указателя на текущего пользователя, и затем выводится информация об этом пользователе с помощью printf.

Как это работает:
Когда компилятор видит CURRENT_USER(), он подставляет вместо этого макроса выражение (&current_user).
Мы могли бы не использовать макрос и просто писать &current_user везде вручную, но макрос помогает сделать код более читаемым и управляемым. Если вдруг мы захотим поменять способ получения текущего пользователя, мы сможем изменить это только в одном месте (в макросе), а не в каждом месте программы, где он используется.
*/