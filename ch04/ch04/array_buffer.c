/*
пример реализации кольцевого буфера, который использует только массив без структуры.
В этом примере массив будет использоваться для хранения данных, а дополнительные переменные будут контролировать состояние буфера.

Пример использования кольцевого буфера в жизни:
Допустим, в вашей почтовой ленте может находиться до 5 посылок одновременно. Вы начинаете с пустой ленты:

Приходят посылки: A, B, C, D, E. Вы кладёте их на ленту, заполняя её до максимума.
Теперь лента полна. Следующая пришедшая посылка F не может просто так быть добавлена. Вы сначала убираете посылку A (самую старую) и кладёте F на её место.
Затем поступает новая посылка G. Вы снова удаляете самую старую посылку (теперь это B) и кладёте G на её место.
Если связать это с программным кодом:

cb_push — это процесс добавления новой посылки на ленту.
cb_pop — это процесс забора старой посылки с ленты для обработки.
cb_full и cb_empty — проверка, есть ли еще место на ленте или она пуста.
*/

#include <stdio.h>
#include <stdbool.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];  // Массив для хранения данных
int head = 0;             // Указатель на начало данных (голова)
int tail = 0;             // Указатель на конец данных (хвост)
bool full = false;        // Флаг, указывающий на заполненность буфера

// Функция добавления элемента в буфер
void push(int item) {
    buffer[head] = item;

    if (full) {
        tail = (tail + 1) % BUFFER_SIZE;  // Если буфер полон, смещаем хвост
    }

    head = (head + 1) % BUFFER_SIZE;

    full = (head == tail);  // Если голова догнала хвост, буфер полон
}

// Функция извлечения элемента из буфера
int pop() {
    if (head == tail && !full) {
        // Буфер пуст, возвращаем -1 или другое значение, сигнализирующее об ошибке
        return -1;
    }

    int item = buffer[tail];
    tail = (tail + 1) % BUFFER_SIZE;
    full = false;  // После извлечения элемента буфер не может быть полным

    return item;
}

// Функция проверки, пуст ли буфер
bool is_empty() {
    return (head == tail && !full);
}

// Функция проверки, полон ли буфер
bool is_full() {
    return full;
}

int main() {
    // Пример использования буфера
    push(1);
    push(2);
    push(3);
    push(4);
    push(5);

    printf("Буфер полон: %s\n", is_full() ? "да" : "нет");

    printf("Элемент: %d\n", pop());
    printf("Элемент: %d\n", pop());

    push(6);

    while (!is_empty()) {
        printf("Элемент: %d\n", pop());
    }

    return 0;
}

/*
Пояснения:
Массив buffer[BUFFER_SIZE]: используется для хранения данных в буфере.
Переменные head и tail: указывают на позиции, где будут вставляться новые элементы (head) и откуда будут извлекаться элементы (tail).
Флаг full: определяет, полон ли буфер. Если голова догоняет хвост, буфер считается полным.

Как это работает:
Добавление (push): Элемент записывается в массив на позицию, указываемую head. Затем указатель head смещается. Если буфер был полон, смещается и указатель tail, чтобы сохранить количество элементов неизменным.
Извлечение (pop): Элемент извлекается с позиции, указываемой tail, после чего указатель tail смещается.
Проверка состояния: is_empty и is_full проверяют, пуст ли буфер или полон.
*/