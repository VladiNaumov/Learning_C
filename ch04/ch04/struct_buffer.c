/*

Кольцевой буфер (или циклический буфер) — это структура данных, которая используется для хранения последовательности данных с фиксированной длиной.
Когда буфер заполняется, новые данные начинают записываться поверх старых, начиная с начала буфера.

Пример использования кольцевого буфера в жизни:
Допустим, в вашей почтовой ленте может находиться до 5 посылок одновременно. Вы начинаете с пустой ленты:

Приходят посылки: A, B, C, D, E. Вы кладёте их на ленту, заполняя её до максимума.
Теперь лента полна. Следующая пришедшая посылка F не может просто так быть добавлена. Вы сначала убираете посылку A (самую старую) и кладёте F на её место.
Затем поступает новая посылка G. Вы снова удаляете самую старую посылку (теперь это B) и кладёте G на её место.
Если связать это с программным кодом:

cb_push — это процесс добавления новой посылки на ленту.
cb_pop — это процесс забора старой посылки с ленты для обработки.
cb_full и cb_empty — проверка, есть ли еще место на ленте или она пуста.

*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    int *buffer;     // Массив для хранения данных
    int head;        // Указатель на начало данных
    int tail;        // Указатель на конец данных
    int max;         // Максимальный размер буфера
    bool full;       // Флаг, указывающий на заполненность буфера
} CircularBuffer;

// Инициализация кольцевого буфера
void cb_init(CircularBuffer *cb, int size) {
    cb->buffer = (int*)malloc(size * sizeof(int));
    cb->max = size;
    cb->head = 0;
    cb->tail = 0;
    cb->full = false;
}

// Освобождение памяти
void cb_free(CircularBuffer *cb) {
    free(cb->buffer);
}

// Вставка элемента в буфер
void cb_push(CircularBuffer *cb, int item) {
    cb->buffer[cb->head] = item;

    if (cb->full) {
        cb->tail = (cb->tail + 1) % cb->max;
    }

    cb->head = (cb->head + 1) % cb->max;

    cb->full = (cb->head == cb->tail);
}

// Извлечение элемента из буфера
int cb_pop(CircularBuffer *cb) {
    if (cb->head == cb->tail && !cb->full) {
        // Буфер пуст
        return -1; // или любое другое значение, сигнализирующее об ошибке
    }

    int item = cb->buffer[cb->tail];
    cb->full = false;
    cb->tail = (cb->tail + 1) % cb->max;

    return item;
}

// Проверка, пуст ли буфер
bool cb_empty(CircularBuffer *cb) {
    return (!cb->full && (cb->head == cb->tail));
}

// Проверка, полон ли буфер
bool cb_full(CircularBuffer *cb) {
    return cb->full;
}

int main() {
    CircularBuffer cb;
    cb_init(&cb, 5);

    cb_push(&cb, 1);
    cb_push(&cb, 2);
    cb_push(&cb, 3);
    cb_push(&cb, 4);
    cb_push(&cb, 5);

    printf("Буфер полон: %s\n", cb_full(&cb) ? "да" : "нет");

    printf("Элемент: %d\n", cb_pop(&cb));
    printf("Элемент: %d\n", cb_pop(&cb));

    cb_push(&cb, 6);

    while (!cb_empty(&cb)) {
        printf("Элемент: %d\n", cb_pop(&cb));
    }

    cb_free(&cb);

    return 0;
}

/*
Пояснение:
Инициализация буфера: Функция cb_init инициализирует буфер заданного размера и устанавливает начальные значения для указателей головы и хвоста.

Добавление данных: Функция cb_push добавляет элемент в буфер. Если буфер полон, указатель хвоста перемещается вперёд, чтобы освободить место для нового элемента.

Извлечение данных: Функция cb_pop извлекает элемент из буфера и перемещает указатель хвоста.

Проверка состояния буфера: Функции cb_empty и cb_full используются для проверки, пуст ли буфер или полон.

Освобождение памяти: Не забывайте освобождать память, когда буфер больше не нужен, чтобы избежать утечек памяти.

*/